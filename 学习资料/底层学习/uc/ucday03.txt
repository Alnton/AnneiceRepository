回顾：
  静态库和共享库的创建和使用
  错误处理 - C程序员对错误的设计/错误处理相关的变量errno和函数strerror/perror
  环境变量在程序中如何处理？
   环境表获取所有的环境变量
   环境表和环境变量的函数：
    getenv/setenv/putenv/unsetenv/clearenv
今天：
    getenv - 按照name(=左边)取value(=右边)
    setenv - 设置新的或者替换已有的 环境变量
       setenv可以用第三个参数决定是否替换
    putenv - 和setenv基本一样，区别在于：参数格式不同，用一个字符串做参数。putenv直接替换已存在的
    unsetenv - 删除一个环境变量
    clearenv - 删除所有环境变量

  主函数的参数：(很少使用)
   main函数其实是有参数的(可以省略)，第一个参数是第二个参数(字符串数组)的长度，第二个参数是执行代码时，输入的命令(用空格隔开多个单词)，第三个参数就是 环境表。
 
 内存管理(Unix/Linux系统)
  内存管理的相关函数图：
   STL -> 内存自动分配和自动回收(C++)
    |
   C++ -> new分配内存 delete回收内存
    |
    C  -> malloc分配内存 free回收内存
    |
  Unix系统函数 -> sbrk/brk 分配和回收内存
    |
  Unix底层系统函数 -> mmap/munmap 分配回收
                                (用户层)
 ―――――――――――――――――――――
                                (内核层)
 Unix内核函数 kmalloc/vmalloc/get_free_page

 进程和程序
   程序是 在硬盘上的可执行的文件。
   进程是 在内存中正在运行的程序。
  进程中内存空间的划分：
   1 代码区 - 存放代码/函数 ，只读区
   2 全局区 - 保存全局变量，static局部变量
   3 BSS段 - 未初始化的全局变量，BSS段在main执行之前会自动清0
   4 栈区 - 局部变量，包括函数的形参，栈区的内存自动分配和自动回收
   5 堆区 - 程序员自己管理的区域，malloc/free操作的都是 堆区。
   6 只读常量区 - 存放字符串常量和const修饰的全局变量 只读区
  注：只读常量区和代码区非常近，有些书把只读常量区和代码区 合并为代码区。

  虚拟内存地址和物理内存
 Linux使用了虚拟内存地址。每个Linux中的进程都有0-4G的虚拟内存地址，就是0-4G的数字。虚拟内存地址在开始时只是一个数字，不对应任何的内存。虚拟内存地址 必须先映射一段物理内存或硬盘上的文件 才能被使用。 所谓的分配内存其实就是 让 虚拟内存地址 映射一段物理内存。如果使用 没有映射的虚拟内存地址 就会引发 段错误。
 程序员所操作的内存地址 都是虚拟内存地址，看不到物理内存地址。
  0-4G的虚拟内存地址中，0-3G是用户使用，叫用户空间，3G-4G是内核使用，叫内核空间。用户空间不能直接访问内核空间，但可以通过内核空间提供的一些函数(系统调用) 访问 内核空间。

  注：内存管理的基本单位是4096字节(4K)，叫一个内存页。内存的映射和回收 都是 以 内存页作为基本单位。

  内存空间分6个区，6个区域如何排列？
  从小到大次序:
   代码区、只读常量区、全局区、BSS段、堆区、栈区
   堆区在离前面4个区不远的地址空间开始，从小到大分配，栈区从接近3G开始，从大到小分配。主要为了避免 堆区和栈区 重叠。
  在Linux，内存的分配是可以查看的。Linux把一切都做成了文件，内存也可以在文件中查看。每个进程都在/proc目录下有一个对应的子目录，以进程ID作为子目录名。进程ID 是系统对进程的标识。可以用 ps -aux命令查看进程。
 cat /proc/进程ID/maps 可以查看当前进程的内存情况。
  
 malloc函数在Unix/Linux的特殊性:
  malloc函数分配内存时，除了分配申请的内存之外，还需要额外留出一些空间，存储内存的相关信息(附加信息)。附加信息保存在一个链表中。
  malloc函数分配内存时，按照 33个内存页分配。如果 一次性申请的内存超过33个内存页，分配出 比 申请内存稍多的 内存页。

  malloc对于内存的分配和free对于内存的释放比较复杂，malloc分配小内存时，以33个内存页作为单位。free并不保证立即释放内存，free到了最后一个变量时，系统 依然会保留 33个内存页不释放
free只能保证 虚拟内存由已经使用 到 没有使用。
  

 什么时候引发段错误？
  1 使用了没有映射的 虚拟内存地址时
  2 对内存执行 没有权限的操作(修改只读区)

 函数getpagesize() 可以取内存页的大小
 
 结论：
  虽然malloc和free 十分复杂，在使用时其实很简单。 malloc负责分配内存，free释放。malloc多大的内存就使用多大。

 每个进程即使虚拟地址一样，对应的物理内存也是不同的。

 brk和sbrk
  brk和sbrk是Unix/Linux的系统函数，只能在Unix/Linux中运行。




