回顾：
  进程 - 子进程创建的第二种方法
   fork()创建子进程 和 父进程相同的代码区，通过不同的返回值 让 父子进程执行不同的代码
   fork()是 父进程 复制自身 得到 子进程
   vfork()一般和exec系列函数结合使用，vfork()负责创建新的子进程，exec函数提供需要执行的程序。
   waitpid - 让父进程等待子进程的结束
  信号 - Unix/Linux做 软件中断
   信号其实就是一个int，Linux 1到64 ， Unix1到48，为了所有的平台都通用，尽量使用 信号的宏定义(SIG开头)。
   信号有可靠信号和非可靠信号之分。
   信号的处理方式：
    1 默认，一般都是退出进程
    2 忽略，对信号不管
    3 自定义处理函数，执行指定的函数代码
    信号的处理方式可以通过signal() 注册
  几个信号发送函数和相关函数：
    raise/kill/alarm/sigqueue
    sleep/usleep
   子进程对父进程信号处理的沿袭性？
 今天：
   kill(pid_t pid,int signo)
   参数： pid 信号接收方的进程ID
     正数 - 就是接受进程的PID(单发)
     0    - 发送给同组所有进程
     -1   - 有权限发送信号的所有进程
     <-1  - 和 -pid 同组的所有进程
   关于信号0 ：
    信号0 被用来 测试 是否有权限发送信号
   alarm()函数作用像 闹钟一样，n秒后产生一个SIGALRM信号
   
   信号集 - 用于存储多个信号
    信号集 类型是 sigset_t ,可以代表多个信号
    信号集 底层就是一个超级大的整数，用 一个二进制位代表一个信号。
   关于集合最基本的函数：
    增加元素、删除元素、查询元素、取出元素
   信号集相关函数：
  sigemptyset - 清空信号集(所有二进制位 置0)
  sigfillset - 填满信号集(所有二进制位 置1)
  sigaddset - 增加一个信号(对应二进制位 置1)
  sigdelset - 删除一个信号(对应二进制位 置0)
  sigismember - 查找是否存在某个信号
 
   信号屏蔽 - 某些关键代码不允许被信号打断，信号屏蔽解决这个问题。
    每个进程都有一个 信号屏蔽字，信号屏蔽字就是一个信号集，默认情况下，不屏蔽任何信号，但可以设置新的 信号屏蔽字 去屏蔽一些信号。
   信号屏蔽函数：sigprocmask
  sigprocmask(int how,sigset_t* new,
   sigset_t* old)
  参数：how 是屏蔽方式
SIG_BLOCK:A B C + C D E ->A B C D E(旧+新)
SIG_UNBLOCK:A B C - C D E -> A B(旧-新)
SIG_SETMASK:A B C  C D E -> C D E(直接新的)
  注：一般都用第三种方式SIG_SETMASK
        new 就是新的信号屏蔽字(被设置的)
        old 用于返回旧的信号屏蔽字    

  注：1 信号屏蔽不是删除信号，而只是把信号先存起来，等 信号屏蔽解除后 还是会处理。
      2 信号屏蔽字 先设置新的，屏蔽完成后 恢复旧的屏蔽字。
   在信号屏蔽 期间 来过的信号可以用 sigpending()获得。

  sigaction() - 增强版的signal()

   C语言的结构中不能写函数，但可以用 函数指针代表函数。

  sigqueue函数在发送信号的同时还能附加数据，这个附加数据存在 siginfo_t 的 si_value中。  

  经验：虽然sigaction()功能更强，但signal更多的被应用。

  信号的应用：计时器
   Linux为每个进程维护了3个计时器：
    真实计时器、虚拟计时器和实用计时器
    一般多采用 真实计时器。
   真实计时器 是 通过产生 SIGALRM 信号工作的
   计时器的函数：
    setitimer()/getitimer()

  进程间通信(IPC)
   两个/多个进程之间数据的交互 叫进程间通信。
  IPC有很多的方法：
   1 文件
   2 信号 
   3 管道
   4 共享内存
   5 消息队列(重点)
   6 信号量集(与signal无关)
   7 网络 
   .....
   其中，4,5,6 统称为 XSI IPC。
    
   管道
    管道的本质也是以文件作为交互媒介，但这个文件是比较特殊的，叫 管道文件。
    管道是 Unix最古老的 IPC，现在 较少使用。
    管道分为 有名管道和无名管道两种。
    有名管道 就是程序员创建 管道文件进行IPC
    无名管道 就是系统创建管道文件进行IPC
    有名管道 可以用于任意进程间的通信，无名管道只能用于 fork创建的 父子进程之间的IPC。

  注：管道文件不会存储数据，只是 一个数据的通道。





