回顾：
  API - 应用程序接口
  文件的相关函数 - stat/access/chmod/truncate/...
 mmap/munmap 针对文件
  目录的相关函数 - mkdir/rmdir/chdir/getcwd
   opendir readdir
今天：
   进程
     ps     : 显示当前终端启动的进程 
     ps -aux: Linux显示进程的命令，Unix不直接支持，但/usr/ucb/ps -aux 可以用。
     ps -ef : Unix/Linux都支持 显示进程
    kill -9 进程号 : 终止进程 
  进程有常见的状态：
   S 休眠状态，大多数进程都处于休眠状态
   R 运行状态
   T 挂起状态
   O 可运行状态
   Z 僵尸进程(已结束的进程，但资源没有回收)

  主流的操作系统都是多进程的。如果一个进程a启动了另外一个进程b，a叫 父进程，b叫 子进程。
   操作系统内核有一个0进程，0进程启动了1进程和2进程(有些Linux只启动1进程)，其他进程都是由1进程和2进程负责启动。

  父子进程之间的关系
   1 父进程启动子进程后，父子进程同时运行。如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源。
   2 父进程启动子进程后，父子进程同时运行。如果父进程先结束，子进程会变成孤儿进程，子进程会重新设置父进程为init进程(进程1)，init进程也叫孤儿院。
   3 父进程启动子进程后，父子进程同时运行。如果子进程先结束，但父进程由于各种原因并没有收到子进程发来的信号，子进程会变成 僵尸进程。

  进程的一些基本函数：
   PID - 进程ID，系统用PID唯一标识一个进程
    延迟重用，每一时刻都可以保证PID唯一
   getpid() - 取当前进程的ID
   getppid() - 取当前进程父进程的ID
   getuid()/geteuid() - 取有效用户ID
   getgid()    -  取用户组id
  PID类型：pid_t 

  fork() - 父进程通过复制自身 创建新的子进程
   fork()创建的子进程会复制 父进程除了代码区的其他内存区域，代码区和父进程共享。
   fork()创建子进程，代码执行的方式：
    1 fork之前的代码 父进程执行1次
    2 fork之后的的代码 父子进程分别执行1次
    3 fork函数的返回值 父子进程分别返回1次 
     子进程返回0，父进程返回 新建子进程的PID
     可以通过返回值的不同，区分父子进程。

   fork()函数不保证谁先运行，但操作系统有自己的调度算法。
   fork()在处理文件描述符时，只复制文件描述符，不复制文件表。
   vfork()和fork()用法类似，但目的不同。
  
  进程的结束：
   正常终止有5种：
    1 在main函数中执行了return 
    2 调用 exit()
    3 调用 _Exit()/_exit()
    4 最后一个线程返回
    5 最后一个线程调用了 pthread_exit()
   非正常终止有2种
    1 信号终止进程
    2 最后一个线程 被其他线程取消
    
  exit()和 _Exit() _exit()区别：
   1 _Exit() _exit()其实是一回事，一个是UC函数，另外一个是标C函数(_Exit())
   2 _Exit()会立即结束进程，不做任何附加事情
   3 exit()会结束进程，但在结束进程之前会调用某些函数(用atexit()注册过的函数)。

  wait()和waitpid() 可以让父进程等待子进程的结束。wait()等待任意一个子进程结束，waitpid()可以有多种选择，包含了wait()的功能。工作方式：
  1 调用wait/waitpid后，父进程开始等待子进程的结束，而父进程自身进入阻塞。
  2 如果没有子进程，父进程立即返回。
  3 如果没有 已经结束的子进程，父进程保持阻塞，直到有一个符合要求的子进程结束为止。
  4 如果有结束的子进程，父进程取到子进程的结束状态码(return 或 exit(参数))并返回。

  pid_t wait(int* status)
   wait等待任意一个子进程的结束，返回 结束子进程的pid，同时把结束码、是否正常结束等信息放入status指针中带出来。
  宏函数 WIFEXITED(status)可以判断是否正常结束 
  WEXITSTATUS(status)可以取得退出码的低8位
  退出码 包括 exit(参数)、_Exit(参数)、return 的值。
  wait函数可以回收僵尸子进程。





