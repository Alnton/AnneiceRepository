回顾：
  线程 - 多线程编程
   线程的创建:pthread_create()
   线程的获取:pthread_self()
   线程的调度函数:pthread_join()
   ......
  线程同步技术 - mutex 互斥量
   
今天：
  信号量
  死锁(了解)
  综合案例--聊天程序
   
   信号量 - 就是一个计数器，控制 同时访问共享资源的线程/进程数量。
   如果信号量 值为1，效果 等同于 互斥量。
   信号量的使用，已经有了固定的API，步骤：
    1 定义一个信号量(semaphore)
      sem_t sem;
    2 初始化信号量
      sem_init(&sem,0,最大值)
     第二个参数必须是0,0代表控制线程，其他值代表控制进程，Linux只支持线程。
      第三个参数就是 计数的初始值，为1信号量的作用等价于互斥量。
    3 获取一个信号量(信号量减1)
      sem_wait(&sem);
    4 访问共享资源
    5 释放一个信号量(信号量加1)
      sem_post(&sem);
    6 如果不再使用，可以删除信号量
      sem_destroy(&sem)

  练习：
   把day14的mutex.c拷贝过来，用信号量实现互斥的效果。

  练习：
   控制访问数据库的最大的并行线程数量
    数据库最多运行10个线程同时访问，启动20个线程，看一下信号量控制的效果。

  死锁 - 线程之间互相锁定，导致所有线程都无法运行。多线程编程 一定要避免死锁。
   避免死锁的经验：
    顺序上锁，反向解锁，不要回调。
   thread1：
    lock(&mutex1);
    ... //1
    lock(&mutex2);//3 thread1阻塞等待mutex2
    ...
    unlock(&mutex2);
    ...
    unlock(&mutex1);
   thread2：
    lock(&mutex2);//2
    ...//4
    lock(&mutex1);//5 thread2阻塞等待mutex1
    ...
    unlock(&mutex1);
    ...
    unlock(&mutex2);

综合案例：
  基于TCP的聊天室 
   100人的聊天室，每个用户都要有一个名字，用户在客户端可以输入名字。每个用户都可以输入要说的话，进行聊天。
   思路：
    TCP服务器端：
     代码7步搞定。写一个结构，成员2个：
      char[] 存储用户名
      int fd 存储sockfd
      定义该结构的数组，长度100，存储所有客户端(不一定够100个)
      每次先从客户端读数据，完了之后群发数据
      新增用户和用户下线 特殊处理。
    TCP客户端：
     代码5步搞定，加上键盘输入函数。
   聊天室做完的同学可以考虑 传送文件。






