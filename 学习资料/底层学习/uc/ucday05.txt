回顾：
  内存管理(sbrk/brk/mmap/munmap)
  文件操作(open/read/write/close)
  文件描述符(本身就是一个非负整数，对应一张文件表，从而代表一个文件)
  系统调用(Unix/Linux的系统函数，作用就是让用户通过调用 系统函数 进入 内核层)
  函数的熟练使用
今天：
  文件操作 - 文件锁、文件的非 读写操作
  目录操作 - 新建目录、读目录的内容...
  读写文件，有2套方案，标C和UC，区别？
   标C函数都有 输入/输出缓冲区，会累积一定数量以后再读写(访问内核)，因此 读写效率较高。
   UC函数 虽然在内核层也有小型缓冲区，但和标C函数的缓冲区比，读写效率较低。
   time 命令可以查看程序的运行时间。
   UC函数在使用时，可以定义自己的缓冲区，从而提升效率。
  
  内存用虚拟内存地址管理，文件用 i节点 管理
  ls -i 可以查看i节点
  
  lseek()可以设置文件偏移量，用法和标C的seek一样。
  dup()和dup2()  - 复制文件描述符
   只复制文件描述符，不复制文件表
  dup()函数只传入源文件描述符，系统选定 复制品描述符的值。
  dup2()函数传入新 旧两个文件描述符，如果新的文件描述符已经被使用，会强行关闭以前的描述符，再复制。

  fcntl()函数(重点)
   fcntl函数比较复杂，主体功能包括：
    1 实现文件描述符的 复制(类似dup)
    2 取/设置文件描述符的状态
    3 文件锁操作
   int fcntl(int fd,int cmd,...)
   1 复制文件描述符：
    cmd 设置为F_DUPFD时，复制文件描述符，需要第三个参数指定 新文件描述符的值。
    与dup2()不同的是：如果指定的文件描述符已经被使用，不强行关闭，而是找能用的最小的 比它大的值(最后的值一定是大于等于第三个参数)。        相对来说，fcntl更安全。
  

   2 获取/设置文件描述符的状态
    F_SETFD/F_GETFD - 文件描述符的状态
    F_SETFL/F_GETFL - 文件标识的状态
   其中，关于文件创建的标识是无法获取的
   修改时，只能修改O_APPEND，文件创建标识和文件权限标识都无法修改。    

   3 文件锁
    多个进程同时读写文件时，有可能引发数据的混乱。如果 所有进程都是读文件，可以同时运行，但只要有写文件进程，都应该 一个挨着一个执行，不能同时运行。
   文件锁可以实现上述的想法。文件锁是读写锁：
   读写锁维护两把锁，一把读锁和一把写锁。
   读锁是一个共享锁，允许其他进程读，但不允许其他进程写。
   写锁是一个互斥锁，不允许其他进程读/写。

  锁定的应用：
   cmd参数用 F_SETLK/F_SETLKW/F_GETLK
   第三个参数是struct flock，成员：
   struct flock{
     short l_type;//锁的类型
     short l_whence;//锁的开始参照点
     int l_start;//开始点的偏移量
     int l_len;//锁定的长度，字节为单位
     pid_t l_pid;//加锁进程ID，只有GETLK有效
   };
  其中，l_type有三种：
   F_RDLCK - 读锁  
   F_WRLCK - 写锁
   F_UNLCK - 释放锁
  l_whence和l_start 两个参数联合决定了开始点
  比如：SEEK_SET 10，从开始向后移动10字节开始锁 

  其实，锁是独立于文件的，并没有真正锁定对文件的读写，锁只能锁定 其他的锁。就是说：如果加了一个锁，会导致第二次加锁失败(两个读锁除外)。
  经验：在调用读函数前加 读锁，根据能否加锁决定是否读文件。在调用写函数之前加 写锁，根据能否加锁决定是否写文件。

  释放锁的方法：
   1 进程结束自动释放所有文件锁
   2 把锁的类型(l_type)改为F_UNLCK后在SETLK




